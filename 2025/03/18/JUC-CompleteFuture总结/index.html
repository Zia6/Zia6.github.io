<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC-CompleteFuture总结 | Zhaixx's Blog</title><meta name="author" content="Zhaixx"><meta name="copyright" content="Zhaixx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CompletableFuture 完全指南 从 Runnable 到 CompletableFuture，全面理解 Java 并发异步编排。  前言在日常开发中，我们经常会遇到需要开启子线程执行任务的场景，比如网络请求、数据库操作、复杂计算等等。Java 为我们提供了多种方式来实现异步操作，从最基础的 Runnable、Callable 到 Future，但这些传统方式在实际使用中存在很多局限，">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC-CompleteFuture总结">
<meta property="og:url" content="https://zia6.github.io/2025/03/18/JUC-CompleteFuture%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Zhaixx&#39;s Blog">
<meta property="og:description" content="CompletableFuture 完全指南 从 Runnable 到 CompletableFuture，全面理解 Java 并发异步编排。  前言在日常开发中，我们经常会遇到需要开启子线程执行任务的场景，比如网络请求、数据库操作、复杂计算等等。Java 为我们提供了多种方式来实现异步操作，从最基础的 Runnable、Callable 到 Future，但这些传统方式在实际使用中存在很多局限，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/134052685?s=400&u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&v=4">
<meta property="article:published_time" content="2025-03-18T01:42:02.000Z">
<meta property="article:modified_time" content="2025-07-18T12:59:15.518Z">
<meta property="article:author" content="Zhaixx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/134052685?s=400&u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&v=4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zia6.github.io/2025/03/18/JUC-CompleteFuture%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC-CompleteFuture总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Zhaixx's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JUC-CompleteFuture总结</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JUC-CompleteFuture总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-18T01:42:02.000Z" title="发表于 2025-03-18 09:42:02">2025-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-18T12:59:15.518Z" title="更新于 2025-07-18 20:59:15">2025-07-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC/">JUC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="CompletableFuture-完全指南"><a href="#CompletableFuture-完全指南" class="headerlink" title="CompletableFuture 完全指南"></a>CompletableFuture 完全指南</h1><blockquote>
<p>从 Runnable 到 CompletableFuture，全面理解 Java 并发异步编排。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发中，我们经常会遇到需要开启子线程执行任务的场景，比如网络请求、数据库操作、复杂计算等等。Java 为我们提供了多种方式来实现异步操作，从最基础的 Runnable、Callable 到 Future，但这些传统方式在实际使用中存在很多局限，尤其是在面对复杂的异步回调、异常处理、任务组合时。<br>本文将带你从最基础的线程模型讲起，一步步剖析为什么 CompletableFuture 会诞生，它到底帮我们解决了哪些问题，以及如何用它优雅地实现高效的异步编排。</p>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#2-runnablecallable-%E4%B8%8E-future%E5%9F%BA%E7%A1%80%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B">2. Runnable、Callable 与 Future：基础异步模型</a><ul>
<li><a href="#21-runnable-%E7%AE%80%E4%BB%8B">2.1 Runnable 简介</a></li>
<li><a href="#22-callable-%E4%B8%8E-future-%E7%AE%80%E4%BB%8B">2.2 Callable 与 Future 简介</a></li>
<li><a href="#23-runnable--callable--future-%E7%9A%84%E5%B1%80%E9%99%90">2.3 Runnable &amp; Callable &amp; Future 的局限</a></li>
</ul>
</li>
<li><a href="#3-completablefuture-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0">3. CompletableFuture 为什么出现？</a></li>
<li><a href="#4-completablefuture-%E6%A0%B8%E5%BF%83%E7%94%A8%E6%B3%95">4. CompletableFuture 核心用法</a><ul>
<li><a href="#41-%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">4.1 创建异步任务</a></li>
<li><a href="#42-%E4%BB%BB%E5%8A%A1%E9%93%BE%E5%BC%8F%E7%BC%96%E6%8E%92">4.2 任务链式编排</a></li>
<li><a href="#43-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88">4.3 多任务组合</a></li>
<li><a href="#44-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">4.4 异常处理</a></li>
</ul>
</li>
<li><a href="#5-completablefuture-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3">5. CompletableFuture 底层实现简单了解</a></li>
<li><a href="#6-completablefuture-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B">6. CompletableFuture 实战案例</a><ul>
<li><a href="#61-%E7%94%B5%E5%95%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%AF%94%E4%BB%B7">6.1 电商多平台比价</a></li>
<li><a href="#62-%E5%A4%9A%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88">6.2 多服务数据聚合</a></li>
</ul>
</li>
<li><a href="#7-%E5%B8%B8%E8%A7%81%E5%9D%91%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93">7. 常见坑与面试题总结</a></li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8. 总结</a></li>
</ul>
<h2 id="2-Runnable、Callable-与-Future：基础异步模型"><a href="#2-Runnable、Callable-与-Future：基础异步模型" class="headerlink" title="2. Runnable、Callable 与 Future：基础异步模型"></a>2. Runnable、Callable 与 Future：基础异步模型</h2><h3 id="2-1-Runnable-简介"><a href="#2-1-Runnable-简介" class="headerlink" title="2.1 Runnable 简介"></a>2.1 Runnable 简介</h3><p>在 Java 并发编程的早期，最基础的异步执行方式是通过实现 <code>Runnable</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 子线程任务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello from Runnable&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code> 接口非常简单，只有一个 <code>run()</code> 方法，特点是 <strong>没有返回值</strong>，也<strong>无法抛出受检异常</strong>。</p>
<p>适用于简单的异步任务，但有两个缺点：</p>
<ul>
<li>无法获取任务执行结果</li>
<li>异常处理不便</li>
</ul>
<hr>
<h3 id="2-2-Callable-与-Future-简介"><a href="#2-2-Callable-与-Future-简介" class="headerlink" title="2.2 Callable 与 Future 简介"></a>2.2 Callable 与 Future 简介</h3><p>为了解决 <code>Runnable</code> 不能返回结果的问题，Java 在 <strong>JDK 1.5</strong> 引入了 <code>Callable</code> 接口，并配套设计了 <code>Future</code> 接口。</p>
<p><strong>Callable 的特点</strong>：</p>
<ul>
<li>方法是 <code>call()</code>，可以有返回值。</li>
<li>可以抛出异常。</li>
</ul>
<p><strong>Future 的作用</strong>：</p>
<ul>
<li>接收异步任务的结果。</li>
<li>提供查询、取消任务、检查是否完成的方法。</li>
</ul>
<p>典型用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">    <span class="comment">// 计算任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Future 常用方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>get()</code></td>
<td>获取结果，阻塞当前线程</td>
</tr>
<tr>
<td><code>get(timeout, unit)</code></td>
<td>带超时等待</td>
</tr>
<tr>
<td><code>isDone()</code></td>
<td>判断任务是否完成</td>
</tr>
<tr>
<td><code>cancel()</code></td>
<td>取消任务</td>
</tr>
<tr>
<td><code>isCancelled()</code></td>
<td>是否被取消</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-Runnable-Callable-Future-的局限"><a href="#2-3-Runnable-Callable-Future-的局限" class="headerlink" title="2.3 Runnable &amp; Callable &amp; Future 的局限"></a>2.3 Runnable &amp; Callable &amp; Future 的局限</h3><p>虽然 <code>Callable + Future</code> 组合可以解决返回值、异常的问题，但在实际开发中仍然有以下缺点：</p>
<ol>
<li><p><strong>get() 方法阻塞</strong><br>调用 <code>future.get()</code> 会阻塞主线程直到子任务完成，不够灵活。</p>
</li>
<li><p><strong>任务编排困难</strong><br>多个异步任务如果存在依赖，需要手动管理，<strong>缺少链式调用支持</strong>。</p>
</li>
<li><p><strong>异常处理繁琐</strong><br>每次调用 <code>get()</code> 都需要 try-catch 显式处理异常。</p>
</li>
<li><p><strong>组合任务困难</strong><br>无法方便地合并多个异步任务结果，缺乏统一 API。</p>
</li>
<li><p><strong>回调机制缺失</strong><br>无法在异步任务完成后自动触发下一步操作，只能手动轮询或阻塞等待。</p>
</li>
</ol>
<hr>
<h2 id="3-CompletableFuture-为什么出现？"><a href="#3-CompletableFuture-为什么出现？" class="headerlink" title="3. CompletableFuture 为什么出现？"></a>3. CompletableFuture 为什么出现？</h2><p><code>Future</code> 解决了异步返回值的问题，但面对复杂业务场景，它的缺陷逐渐显现：</p>
<ul>
<li><strong>无法实现异步任务链式编排</strong></li>
<li><strong>不支持非阻塞地获取结果</strong></li>
<li><strong>缺乏优雅的异常处理机制</strong></li>
<li><strong>多任务并发执行后结果整合困难</strong></li>
</ul>
<p>为了解决这些问题，Java 在 <strong>JDK 1.8</strong> 引入了 <strong>CompletableFuture</strong>，它不仅实现了 <code>Future</code> 接口，还提供了丰富的功能：</p>
<ul>
<li>支持链式调用，轻松实现任务依赖关系。</li>
<li>支持非阻塞获取结果。</li>
<li>提供优雅的异常处理方法。</li>
<li>内置多任务组合、合并结果功能。</li>
</ul>
<p>接下来我们详细了解 <code>CompletableFuture</code> 的用法及其背后的设计理念。</p>
<hr>
<h2 id="4-CompletableFuture-核心用法"><a href="#4-CompletableFuture-核心用法" class="headerlink" title="4. CompletableFuture 核心用法"></a>4. CompletableFuture 核心用法</h2><h3 id="4-1-创建异步任务"><a href="#4-1-创建异步任务" class="headerlink" title="4.1 创建异步任务"></a>4.1 创建异步任务</h3><p><code>CompletableFuture</code> 提供两种创建异步任务的方法：</p>
<ul>
<li><code>runAsync()</code> ：无返回值，类似 <code>Runnable</code></li>
<li><code>supplyAsync()</code> ：有返回值，类似 <code>Callable</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line">CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Run async task&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>你也可以指定自定义线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>, executor);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-任务链式编排"><a href="#4-2-任务链式编排" class="headerlink" title="4.2 任务链式编排"></a>4.2 任务链式编排</h3><p><code>CompletableFuture</code> 支持链式调用，轻松实现异步任务依赖关系：</p>
<ul>
<li><code>thenApply()</code> ：对结果进行转换</li>
<li><code>thenAccept()</code> ：消费结果，无返回</li>
<li><code>thenRun()</code> ：不依赖结果，仅执行后续动作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="number">5</span>)</span><br><span class="line">    .thenApply(result -&gt; result * <span class="number">2</span>)</span><br><span class="line">    .thenAccept(result -&gt; System.out.println(<span class="string">&quot;Result: &quot;</span> + result))</span><br><span class="line">    .thenRun(() -&gt; System.out.println(<span class="string">&quot;Task finished&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="组合依赖"><a href="#组合依赖" class="headerlink" title="组合依赖"></a>组合依赖</h4><ul>
<li><code>thenCompose()</code> ：任务串联，前后依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot; World&quot;</span>))</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>thenCombine()</code> ：两个独立任务结果合并</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">future1.thenCombine(future2, Integer::sum)</span><br><span class="line">       .thenAccept(result -&gt; System.out.println(<span class="string">&quot;Sum: &quot;</span> + result));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-多任务组合"><a href="#4-3-多任务组合" class="headerlink" title="4.3 多任务组合"></a>4.3 多任务组合</h3><p><code>CompletableFuture</code> 提供两个重要方法来处理多任务：</p>
<ul>
<li><code>allOf()</code> ：等待所有任务完成</li>
<li><code>anyOf()</code> ：任意一个完成即可继续</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(future1, future2);</span><br><span class="line">all.thenRun(() -&gt; System.out.println(<span class="string">&quot;All tasks done&quot;</span>));</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Object&gt; any = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">any.thenAccept(result -&gt; System.out.println(<span class="string">&quot;First finished: &quot;</span> + result));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-异常处理"><a href="#4-4-异常处理" class="headerlink" title="4.4 异常处理"></a>4.4 异常处理</h3><p>异常在异步编排中非常重要，<code>CompletableFuture</code> 提供了两种优雅的异常处理方式：</p>
<ul>
<li><code>exceptionally()</code> ：发生异常时提供默认值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Exception: &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;).thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>handle()</code> ：可以同时处理正常结果和异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Fail&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;).handle((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Handle exception: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-CompletableFuture-底层实现简单了解"><a href="#5-CompletableFuture-底层实现简单了解" class="headerlink" title="5. CompletableFuture 底层实现简单了解"></a>5. CompletableFuture 底层实现简单了解</h2><p><code>CompletableFuture</code> 底层依托于 <strong>ForkJoinPool</strong> 线程池实现异步任务调度。默认情况下，使用的是 <code>ForkJoinPool.commonPool()</code>，它内部采用 <strong>工作窃取算法</strong> 提高线程利用率。</p>
<p>核心设计要点：</p>
<ul>
<li>每个异步任务会被包装成一个 <code>ForkJoinTask</code>，提交到线程池中执行。</li>
<li>任务之间的回调关系，依靠 <strong>Completion 队列</strong> 实现，保证每个阶段完成后能够自动触发下一个动作。</li>
</ul>
<p>核心数据结构：</p>
<ul>
<li><strong>result</strong>：保存任务的返回值或异常</li>
<li><strong>stack</strong>：保存回调链</li>
</ul>
<p>你也可以通过指定自定义线程池，避免共用 <code>ForkJoinPool</code> 带来的影响，特别是在 Web 容器中推荐自定义线程池。</p>
<hr>
<h2 id="6-CompletableFuture-实战案例"><a href="#6-CompletableFuture-实战案例" class="headerlink" title="6. CompletableFuture 实战案例"></a>6. CompletableFuture 实战案例</h2><h3 id="6-1-电商多平台比价"><a href="#6-1-电商多平台比价" class="headerlink" title="6.1 电商多平台比价"></a>6.1 电商多平台比价</h3><p>需求：查询不同电商平台同一商品价格，汇总最低价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; platforms = Arrays.asList(<span class="string">&quot;JD&quot;</span>, <span class="string">&quot;Taobao&quot;</span>, <span class="string">&quot;PDD&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;CompletableFuture&lt;Double&gt;&gt; priceFutures = platforms.stream()</span><br><span class="line">    .map(platform -&gt; CompletableFuture.supplyAsync(() -&gt; queryPrice(platform)))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(priceFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]))</span><br><span class="line">    .thenRun(() -&gt; &#123;</span><br><span class="line">        List&lt;Double&gt; prices = priceFutures.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;All prices: &quot;</span> + prices);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">queryPrice</span><span class="params">(String platform)</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> Math.random() * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-2-多服务数据聚合"><a href="#6-2-多服务数据聚合" class="headerlink" title="6.2 多服务数据聚合"></a>6.2 多服务数据聚合</h3><p>假设需要聚合用户信息、账户信息、积分信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;User&gt; userFuture = CompletableFuture.supplyAsync(() -&gt; queryUser());</span><br><span class="line">CompletableFuture&lt;Account&gt; accountFuture = CompletableFuture.supplyAsync(() -&gt; queryAccount());</span><br><span class="line">CompletableFuture&lt;Score&gt; scoreFuture = CompletableFuture.supplyAsync(() -&gt; queryScore());</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(userFuture, accountFuture, scoreFuture)</span><br><span class="line">    .thenRun(() -&gt; &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userFuture.join();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountFuture.join();</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> scoreFuture.join();</span><br><span class="line">        <span class="comment">// 合并结果</span></span><br><span class="line">        System.out.println(user + <span class="string">&quot; &quot;</span> + account + <span class="string">&quot; &quot;</span> + score);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-常见坑与面试题总结"><a href="#7-常见坑与面试题总结" class="headerlink" title="7. 常见坑与面试题总结"></a>7. 常见坑与面试题总结</h2><h3 id="7-1-get-和-join-有什么区别？"><a href="#7-1-get-和-join-有什么区别？" class="headerlink" title="7.1 get() 和 join() 有什么区别？"></a>7.1 get() 和 join() 有什么区别？</h3><ul>
<li><code>get()</code> 会抛出 checked 异常，需要显式处理。</li>
<li><code>join()</code> 会将异常包装成 <code>CompletionException</code>，无需显示捕获，推荐链式调用时使用。</li>
</ul>
<h3 id="7-2-默认线程池安全吗？"><a href="#7-2-默认线程池安全吗？" class="headerlink" title="7.2 默认线程池安全吗？"></a>7.2 默认线程池安全吗？</h3><p>默认使用 <code>ForkJoinPool.commonPool()</code>，在高并发场景或 Web 应用中可能会导致线程被占满，<strong>推荐自定义线程池</strong>。</p>
<h3 id="7-3-如何优雅处理异常？"><a href="#7-3-如何优雅处理异常？" class="headerlink" title="7.3 如何优雅处理异常？"></a>7.3 如何优雅处理异常？</h3><p>优先使用 <code>handle()</code>，同时处理正常和异常；或者 <code>exceptionally()</code> 提供默认值，避免影响主线程。</p>
<h3 id="7-4-面试高频问题"><a href="#7-4-面试高频问题" class="headerlink" title="7.4 面试高频问题"></a>7.4 面试高频问题</h3><ul>
<li>CompletableFuture 的优点有哪些？</li>
<li>thenCompose 和 thenCombine 区别？</li>
<li>allOf 和 anyOf 使用场景？</li>
<li>异常处理机制有哪些？</li>
</ul>
<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>从 Runnable、Callable + Future 到 CompletableFuture，Java 并发异步工具的发展，正是为了解决异步流程中<strong>编排复杂、异常处理、结果整合</strong>等问题。</p>
<p>掌握好 <code>CompletableFuture</code>，可以帮助我们写出高效、优雅、健壮的异步代码，真正解决开发中的异步回调地狱、线程阻塞问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zia6.github.io">Zhaixx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zia6.github.io/2025/03/18/JUC-CompleteFuture%E6%80%BB%E7%BB%93/">https://zia6.github.io/2025/03/18/JUC-CompleteFuture%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zia6.github.io" target="_blank">Zhaixx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/134052685?s=400&amp;u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/18/JUC-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" title="JUC-多线程锁原理详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JUC-多线程锁原理详解</div></div><div class="info-2"><div class="info-item-1">Java 多线程锁原理详解 —— 从字节码到 JVM 实现全解Java 并发编程离不开对“锁”机制的理解与掌握。无论是最基础的 synchronized，还是功能丰富的 ReentrantLock，亦或是高效提升读操作性能的 ReadWriteLock，它们背后蕴含的实现原理和适用场景各有千秋。 本文将从为什么需要锁讲起，结合 字节码、JVM 实现，一步步剖析各类锁的底层机制，帮助你彻底掌握多线程锁的原理。  目录 1. 为什么需要锁？ 2. 可重入锁是什么？ 3. synchronized 详解 3.1 基本用法 3.2 字节码与 JVM 实现 3.3 优缺点总结   4. wait&#x2F;notify 机制详解 5. ReentrantLock 详解 5.1 基本用法 5.2 公平锁与非公平锁 5.3 tryLock 与中断 5.4 Condition 精准唤醒 5.5 Condition vs wait&#x2F;notify 对比   6. 读写锁 ReadWriteLock 6.1 原理与用法 6.2 适用场景   7. StampedLock 简介 8....</div></div></div></a><a class="pagination-related" href="/2025/02/20/SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" title="SQL性能分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SQL性能分析</div></div><div class="info-2"><div class="info-item-1">SQL性能分析(MySQL)SQL执行频次查询MySQL客户端连接成功后，通过show[session | global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次: 1SHOW GLOBAL STATUS LIKE...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/134052685?s=400&amp;u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhaixx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zia6"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Zia6" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:z20230404@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CompletableFuture-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97"><span class="toc-number">1.</span> <span class="toc-text">CompletableFuture 完全指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Runnable%E3%80%81Callable-%E4%B8%8E-Future%EF%BC%9A%E5%9F%BA%E7%A1%80%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">2. Runnable、Callable 与 Future：基础异步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Runnable-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 Runnable 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Callable-%E4%B8%8E-Future-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 Callable 与 Future 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Runnable-Callable-Future-%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 Runnable &amp; Callable &amp; Future 的局限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CompletableFuture-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">3. CompletableFuture 为什么出现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-CompletableFuture-%E6%A0%B8%E5%BF%83%E7%94%A8%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">4. CompletableFuture 核心用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 创建异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BB%BB%E5%8A%A1%E9%93%BE%E5%BC%8F%E7%BC%96%E6%8E%92"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 任务链式编排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BE%9D%E8%B5%96"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">组合依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 多任务组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-CompletableFuture-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">5. CompletableFuture 底层实现简单了解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-CompletableFuture-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.</span> <span class="toc-text">6. CompletableFuture 实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%94%B5%E5%95%86%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%AF%94%E4%BB%B7"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1 电商多平台比价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%A4%9A%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 多服务数据聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81%E5%9D%91%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">7. 常见坑与面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-get-%E5%92%8C-join-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1 get() 和 join() 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%BB%98%E8%AE%A4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2 默认线程池安全吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3 如何优雅处理异常？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.4.</span> <span class="toc-text">7.4 面试高频问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">8. 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/15/6-824ShardKV%E5%AE%9E%E7%8E%B0/" title="6.824ShardKV实现">6.824ShardKV实现</a><time datetime="2025-08-15T08:34:22.000Z" title="发表于 2025-08-15 16:34:22">2025-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/30/6-824-%E5%AE%9E%E7%8E%B0-raft-kv/" title="6.824-实现 raft_kv">6.824-实现 raft_kv</a><time datetime="2025-07-30T02:48:37.000Z" title="发表于 2025-07-30 10:48:37">2025-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/18/raft%E5%AE%9E%E7%8E%B0/" title="raft实现">raft实现</a><time datetime="2025-07-18T11:46:03.000Z" title="发表于 2025-07-18 19:46:03">2025-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/14/TCP-Reciver-Sender%E5%AE%9E%E7%8E%B0/" title="TCP Receiver Sender实现">TCP Receiver Sender实现</a><time datetime="2025-07-14T12:32:10.000Z" title="发表于 2025-07-14 20:32:10">2025-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/23/Google-File-System%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB/" title="Google File System设计阅读">Google File System设计阅读</a><time datetime="2025-05-23T02:00:19.000Z" title="发表于 2025-05-23 10:00:19">2025-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Zhaixx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>