<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP Receiver Sender实现 | Zhaixx's Blog</title><meta name="author" content="Zhaixx"><meta name="copyright" content="Zhaixx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CS144 TCP Receiver &amp; Sender 实现笔记这是我做CS144的TCP实现部分的一些记录，主要是为了以后复习的时候能快速回忆起当时的思路。 StreamReassembler 实现在搞TCP Receiver之前得先把StreamReassembler搞定，这个东西就是用来把乱序的数据包重新排好序的。 我的实现思路我用了一个set来存放所有的segment，按照起始位置">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP Receiver Sender实现">
<meta property="og:url" content="https://zia6.github.io/2025/07/14/TCP-Reciver-Sender%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Zhaixx&#39;s Blog">
<meta property="og:description" content="CS144 TCP Receiver &amp; Sender 实现笔记这是我做CS144的TCP实现部分的一些记录，主要是为了以后复习的时候能快速回忆起当时的思路。 StreamReassembler 实现在搞TCP Receiver之前得先把StreamReassembler搞定，这个东西就是用来把乱序的数据包重新排好序的。 我的实现思路我用了一个set来存放所有的segment，按照起始位置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/134052685?s=400&u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&v=4">
<meta property="article:published_time" content="2025-07-14T12:32:10.000Z">
<meta property="article:modified_time" content="2025-07-18T11:45:45.063Z">
<meta property="article:author" content="Zhaixx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://avatars.githubusercontent.com/u/134052685?s=400&u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&v=4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zia6.github.io/2025/07/14/TCP-Reciver-Sender%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP Receiver Sender实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Zhaixx's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP Receiver Sender实现</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">TCP Receiver Sender实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-14T12:32:10.000Z" title="发表于 2025-07-14 20:32:10">2025-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-18T11:45:45.063Z" title="更新于 2025-07-18 19:45:45">2025-07-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="CS144-TCP-Receiver-Sender-实现笔记"><a href="#CS144-TCP-Receiver-Sender-实现笔记" class="headerlink" title="CS144 TCP Receiver &amp; Sender 实现笔记"></a>CS144 TCP Receiver &amp; Sender 实现笔记</h1><p>这是我做CS144的TCP实现部分的一些记录，主要是为了以后复习的时候能快速回忆起当时的思路。</p>
<h2 id="StreamReassembler-实现"><a href="#StreamReassembler-实现" class="headerlink" title="StreamReassembler 实现"></a>StreamReassembler 实现</h2><p>在搞TCP Receiver之前得先把StreamReassembler搞定，这个东西就是用来把乱序的数据包重新排好序的。</p>
<h3 id="我的实现思路"><a href="#我的实现思路" class="headerlink" title="我的实现思路"></a>我的实现思路</h3><p>我用了一个set来存放所有的segment，按照起始位置排序。最关键的是要保证一个规律：<strong>set里面的所有segment都不能重叠</strong>。</p>
<p>每次来新的segment的时候：</p>
<ol>
<li>先找出所有和它重叠的segment</li>
<li>把这些重叠的都删掉</li>
<li>然后把它们全部合并成一个大的segment</li>
<li>再把这个合并后的segment放回set</li>
</ol>
<p>这样搞的好处是，后面往ByteStream里写数据的时候就很简单了，直接从头开始写，碰到第一个不连续的地方就停。</p>
<h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><p>TCP就是靠两对(Receiver, Sender)来搞双向通信的：</p>
<p>发送端：Sender.send() → 网络 → Receiver.receive()<br>接收端：Receiver.send() → 网络 → Sender.receive()</p>
<p>接收端要通过ACK告诉发送端：</p>
<ul>
<li>下一个想要的序列号是啥</li>
<li>我的窗口还有多大</li>
<li>有没有出错</li>
</ul>
<h2 id="Wrap32-这个坑"><a href="#Wrap32-这个坑" class="headerlink" title="Wrap32 这个坑"></a>Wrap32 这个坑</h2><p>这个Wrap32是个很坑的东西。当年TCP设计的时候网络没这么快，32位够用了。但现在32位会循环，所以一个Wrap32可能对应好几个真实的64位index。</p>
<p>包装很简单：<code>(真实index + ISN) % (1&lt;&lt;32)</code></p>
<p>解包装就麻烦了，得结合ISN和最近的已知index来推断。</p>
<p>有个细节要注意：发送端的起始index &#x3D; 接收端index - 1，因为发送端要给SYN占一个位置。</p>
<h2 id="TCP-Receiver-实现"><a href="#TCP-Receiver-实现" class="headerlink" title="TCP Receiver 实现"></a>TCP Receiver 实现</h2><h3 id="receive方法"><a href="#receive方法" class="headerlink" title="receive方法"></a>receive方法</h3><p>主要处理流程：</p>
<ol>
<li>先看看有没有RST标志，有的话直接报错</li>
<li>看看有没有SYN标志，有的话就设置ISN</li>
<li>如果ISN已经设置了，就把序列号解包装，然后丢给reassembler处理</li>
</ol>
<h3 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h3><p>这个简单，就是发个ACK，告诉对方下一个要的序列号和窗口大小。</p>
<h2 id="TCP-Sender-实现"><a href="#TCP-Sender-实现" class="headerlink" title="TCP Sender 实现"></a>TCP Sender 实现</h2><p>这个是最复杂的部分，要处理分段、超时、重传什么的。</p>
<h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><ul>
<li>发送缓冲区：存要发送的数据</li>
<li>未确认队列：跟踪已发送但还没收到ACK的segment</li>
<li>重传定时器：处理超时重传</li>
</ul>
<h3 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h3><p>就是把ByteStream里的数据按照窗口大小和MAX_PAYLOAD_SIZE分段发送。要注意的是：</p>
<ul>
<li>先算出能发送的最大字节数（窗口大小和MAX_PAYLOAD_SIZE的最小值）</li>
<li>从ByteStream读数据</li>
<li>如果数据读完了并且还有空间，就带上FIN标志</li>
<li>发送完如果定时器没开就开启定时器</li>
</ul>
<h3 id="receive方法-1"><a href="#receive方法-1" class="headerlink" title="receive方法"></a>receive方法</h3><p>处理收到的ACK：</p>
<ul>
<li>更新窗口大小</li>
<li>把已确认的segment从未确认队列里删掉</li>
<li>如果有新数据被确认，就重启定时器并重置RTO</li>
</ul>
<h3 id="tick方法"><a href="#tick方法" class="headerlink" title="tick方法"></a>tick方法</h3><p>处理超时重传：</p>
<ul>
<li>如果超时了并且有未确认的segment，就重传最早的那个</li>
<li>如果窗口大小大于0，RTO要翻倍（指数退避）</li>
<li>如果窗口为0，RTO不翻倍（这是零窗口探测）</li>
</ul>
<h2 id="一些踩坑的地方"><a href="#一些踩坑的地方" class="headerlink" title="一些踩坑的地方"></a>一些踩坑的地方</h2><h3 id="零窗口探测"><a href="#零窗口探测" class="headerlink" title="零窗口探测"></a>零窗口探测</h3><p>当接收方窗口为0时，发送方要定期发探测包，但这时候不能执行指数退避，不然探测频率会越来越低。</p>
<h3 id="重传策略"><a href="#重传策略" class="headerlink" title="重传策略"></a>重传策略</h3><p>有两种重传：</p>
<ul>
<li>超时重传：RTO到期触发</li>
<li>快速重传：收到重复ACK触发</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>一定要严格按照接收方的窗口大小来发送，不能发多了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP实现最麻烦的就是各种边界情况的处理。不过只要数据结构设计得合理，状态管理清楚，问题就不大。</p>
<p>主要要注意的几个点：</p>
<ul>
<li>StreamReassembler的segment合并算法</li>
<li>Wrap32的包装和解包装</li>
<li>Sender的超时重传机制</li>
<li>各种TCP标志位的正确处理</li>
</ul>
<p>写完之后感觉对TCP的理解深了不少，特别是对那些平时看书觉得很抽象的概念有了更直观的认识。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zia6.github.io">Zhaixx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zia6.github.io/2025/07/14/TCP-Reciver-Sender%E5%AE%9E%E7%8E%B0/">https://zia6.github.io/2025/07/14/TCP-Reciver-Sender%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zia6.github.io" target="_blank">Zhaixx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/134052685?s=400&amp;u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/18/raft%E5%AE%9E%E7%8E%B0/" title="raft实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">raft实现</div></div><div class="info-2"><div class="info-item-1">Lab3 Raft实现3A3A 主要是不考虑状态机的情况下，实现 Raft Leader选举和心跳机制，确保选举出单一 Leader，如果没有故障就保持 Leader，如果 Leader 故障或者包丢失，则选举新的 Leader ticker实现我们需要实现超时机制，在一定时间后没有心跳，则我们需要进行选举 选举实现具体实现参照此图即可，需要注意的点如下  在向其他服务器发送 RequestVote 时，需要将锁释放，不然有可能出现多个 Candidater相互要票却无法投票的情况，因为投票也需要加锁，所以会产生死锁 在一台服务器决定是否投票时，如果收到的 Term 大于自身 CurrentTerm，需要更新自身 Term 并更新 VoteFor(我没更新 VoteFor 卡了好久)，因为没更新 VoteFor 会导致它进入下一个 Term 但是不能投票的情况出现，进而导致选举不出 Leader 发送心跳时也尽量不要锁整个函数，如果出现特殊情况也可能导致死锁，出现两个 Leader 虽然不是同一 Term 但有可能相互要锁导致死锁。  </div></div></div></a><a class="pagination-related" href="/2025/05/23/Google-File-System%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB/" title="Google File System设计阅读"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Google File System设计阅读</div></div><div class="info-2"><div class="info-item-1">背景在 Google 早期，随着其搜索引擎和各项服务数据量的爆炸式增长，传统的文件系统已经无法满足其日益严苛的需求。为了应对海量数据的存储和处理挑战，Google 内部设计并实现了一个高度可扩展、高可用且容错的分布式文件系统——Google 文件系统 (GFS)。GFS 的设计理念和技术实践深刻影响了后续 Hadoop HDFS 等一系列大数据存储系统。 GFS 的设计基于以下核心需求和假设：  硬件不可靠性常态化： 系统由大量廉价的商用硬件构建，这些组件的故障是常态，而非异常。因此，系统必须具备强大的故障监控、检测和自动恢复能力。 存储重心在大文件： GFS 主要面向大文件（GB 乃至 TB 级别）存储进行优化，例如 Web 爬虫数据、搜索引擎索引、视频文件等。虽然支持小文件，但并非其优化重点。 工作负载特性鲜明： 读取模式： 以大型流式读取（一次性读取大量连续数据）为主，也支持小型的随机读取。 写入模式： 大型追加写入（将数据追加到文件末尾）是主要场景，文件写入后很少被修改。小写入也支持，但效率不高。   高并发追加需求：...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/134052685?s=400&amp;u=6df3485aa0fbf1016b0d5e00de4cfd71630a5f57&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zhaixx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zia6"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Zia6" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:z20230404@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CS144-TCP-Receiver-Sender-%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">CS144 TCP Receiver &amp; Sender 实现笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#StreamReassembler-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">StreamReassembler 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">我的实现思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">TCP通信流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wrap32-%E8%BF%99%E4%B8%AA%E5%9D%91"><span class="toc-number">1.3.</span> <span class="toc-text">Wrap32 这个坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-Receiver-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">TCP Receiver 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#receive%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">receive方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">send方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-Sender-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">TCP Sender 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">主要数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">push方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#receive%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">receive方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tick%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">tick方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.6.</span> <span class="toc-text">一些踩坑的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">零窗口探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">重传策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">流量控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/18/raft%E5%AE%9E%E7%8E%B0/" title="raft实现">raft实现</a><time datetime="2025-07-18T11:46:03.000Z" title="发表于 2025-07-18 19:46:03">2025-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/14/TCP-Reciver-Sender%E5%AE%9E%E7%8E%B0/" title="TCP Receiver Sender实现">TCP Receiver Sender实现</a><time datetime="2025-07-14T12:32:10.000Z" title="发表于 2025-07-14 20:32:10">2025-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/23/Google-File-System%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB/" title="Google File System设计阅读">Google File System设计阅读</a><time datetime="2025-05-23T02:00:19.000Z" title="发表于 2025-05-23 10:00:19">2025-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/20/6-824Lab1-Mapreduce%E8%AE%BE%E8%AE%A1/" title="6.824Lab1-Mapreduce设计">6.824Lab1-Mapreduce设计</a><time datetime="2025-05-20T08:33:57.000Z" title="发表于 2025-05-20 16:33:57">2025-05-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/18/MapReduce%E5%AD%A6%E4%B9%A0/" title="MapReduce学习">MapReduce学习</a><time datetime="2025-05-18T06:11:49.000Z" title="发表于 2025-05-18 14:11:49">2025-05-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Zhaixx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>