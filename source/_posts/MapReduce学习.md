---
title: MapReduce学习
date: 2025-05-18 14:11:49
tags:
catagories: 6.824分布式系统
---

## 背景
Google需要处理大量的数据，在这些数据的基础上进行海量的计算，或者去分析整个网络的链接结构，这个过程本质上是对整个网络的内容去进行排序，这是非常耗费资源的一件事，使用单台计算机需要相当长的时间，于是Google希望能在成千上万台机器上去并行处理这些事情以缩短处理的时间，尽管如此，工程师们还是需要去手动的将任务分配给每台机器，这也是很费劲的事情，因此我们需要一个框架，能够让工程师只编写一个任务的核心部分，或者说能让非分布式专业的程序员也能够在分布式的系统上设计应用，于是便有了MapReduce。

## 运行过程
用户上传需要处理的文件，框架会对这些Input Resource进行分割用于并行化的处理，然后对分割后的文件按照用户的要求进行Map，对分割后的每一个Input输出一组Key-Value键值对，这些键值对会被后续的Reduce调用进行处理，比如说一个词频统计，MapReduce会对文件中的每一个Word生成一个键值对，比如说(a1,b1),(a2,b2)，然后会调用Reduce对这些键值对进行统计，最终输出每个Word的数量。
## 模型设计
我们要传入一个Map函数，形如Map(k,v)，这个k是一个文件名，实际上并不重要，重要的是这个v,它是文件本身，然后我们会对每一个 v 进行处理，把这个 v 按照 word 进行分割，对每一个 word 输出一个(key,value),比如说 ("word",1)，下面是示例伪代码.
```cpp
Map(k,v)
// split v into word
for(word : v){
    emit("word",1);
}
```
然后调用 Reduce ，对所有相同的 key 进行规约或者说合并，比如说我们这个词频统计，就会将所有的 value 加起来，然后输出。

值得一提的是，我们可以将 Reduce 的输出再次作为输入，比如说因为我们第一次做 MapReduce 输出的是多个最终文件，我们可以把它作为输入再次处理，将 Reduce 的处理参数设置为 1 即可，这里是因为调用这个框架的时候我们需要传递进入一个 N 和 M ，N 代表我们将输入资源分成 N 份进行Map处理，而 M 代表我们将 Reduce 过程分成 M 个区域，每个 Map 输出的中间键值对，会根据算法或者 Hash 分配到某一个Reduce，这 M 个Reduce 会进行并行的处理，进而输出 M 的 Reduce 结果，我们可以将这些结果再次输入，然后进行合并。

## 参考资料
- [MapReduce(2004)](https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf)




